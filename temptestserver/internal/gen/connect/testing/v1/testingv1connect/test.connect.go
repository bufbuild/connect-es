// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: testing/v1/test.proto

package testingv1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	v1 "github.com/bufbuild/connect-web/testserver/internal/gen/go/testing/v1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_0_1

const (
	// TestServiceName is the fully-qualified name of the TestService service.
	TestServiceName = "testing.v1.TestService"
)

// TestServiceClient is a client for the testing.v1.TestService service.
type TestServiceClient interface {
	// Returns the numeric value from the request as a string in the response
	UnaryHappy(context.Context, *connect_go.Request[v1.UnaryHappyRequest]) (*connect_go.Response[v1.UnaryHappyResponse], error)
	// Always raises an error "already_exists", and a message with whitespace
	// and unicode content
	UnaryError(context.Context, *connect_go.Request[v1.UnaryErrorRequest]) (*connect_go.Response[v1.UnaryErrorResponse], error)
	// Responds with headers:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar,baz
	UnaryHeaders(context.Context, *connect_go.Request[v1.UnaryHeadersRequest]) (*connect_go.Response[v1.UnaryHeadersResponse], error)
	// Responds with trailers:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar,baz
	UnaryTrailers(context.Context, *connect_go.Request[v1.UnaryTrailersRequest]) (*connect_go.Response[v1.UnaryTrailersResponse], error)
	// Expects a set of headers in the request:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar, baz
	// Clients may join the two `separate-values` headers into one, with values
	// separated by `, `. Errors with invalid_argument if not met.
	UnaryExpectHeaders(context.Context, *connect_go.Request[v1.UnaryExpectHeadersRequest]) (*connect_go.Response[v1.UnaryExpectHeadersResponse], error)
	// Not implemented by the server
	UnaryUnimplemented(context.Context, *connect_go.Request[v1.UnaryUnimplementedRequest]) (*connect_go.Response[v1.UnaryUnimplementedResponse], error)
	// Returns exactly 5 responses. The value from the request is incremented
	// and given in each response.
	ServerStreamingHappy(context.Context, *connect_go.Request[v1.ServerStreamingHappyRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingHappyResponse], error)
	// Always raises an error "already_exists", and a message with whitespace
	// and unicode content
	ServerStreamingError(context.Context, *connect_go.Request[v1.ServerStreamingErrorRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingErrorResponse], error)
	ServerStreamingEmpty(context.Context, *connect_go.Request[v1.ServerStreamingEmptyRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingEmptyResponse], error)
	ServerStreamingUnimplemented(context.Context, *connect_go.Request[v1.ServerStreamingUnimplementedRequest]) (*connect_go.Response[v1.ServerStreamingUnimplementedResponse], error)
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context) *connect_go.BidiStreamForClient[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse]
}

// NewTestServiceClient constructs a client for the testing.v1.TestService service. By default, it
// uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses, and sends
// uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the connect.WithGRPC() or
// connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTestServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) TestServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &testServiceClient{
		unaryHappy: connect_go.NewClient[v1.UnaryHappyRequest, v1.UnaryHappyResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryHappy",
			opts...,
		),
		unaryError: connect_go.NewClient[v1.UnaryErrorRequest, v1.UnaryErrorResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryError",
			opts...,
		),
		unaryHeaders: connect_go.NewClient[v1.UnaryHeadersRequest, v1.UnaryHeadersResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryHeaders",
			opts...,
		),
		unaryTrailers: connect_go.NewClient[v1.UnaryTrailersRequest, v1.UnaryTrailersResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryTrailers",
			opts...,
		),
		unaryExpectHeaders: connect_go.NewClient[v1.UnaryExpectHeadersRequest, v1.UnaryExpectHeadersResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryExpectHeaders",
			opts...,
		),
		unaryUnimplemented: connect_go.NewClient[v1.UnaryUnimplementedRequest, v1.UnaryUnimplementedResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/UnaryUnimplemented",
			opts...,
		),
		serverStreamingHappy: connect_go.NewClient[v1.ServerStreamingHappyRequest, v1.ServerStreamingHappyResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/ServerStreamingHappy",
			opts...,
		),
		serverStreamingError: connect_go.NewClient[v1.ServerStreamingErrorRequest, v1.ServerStreamingErrorResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/ServerStreamingError",
			opts...,
		),
		serverStreamingEmpty: connect_go.NewClient[v1.ServerStreamingEmptyRequest, v1.ServerStreamingEmptyResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/ServerStreamingEmpty",
			opts...,
		),
		serverStreamingUnimplemented: connect_go.NewClient[v1.ServerStreamingUnimplementedRequest, v1.ServerStreamingUnimplementedResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/ServerStreamingUnimplemented",
			opts...,
		),
		fullDuplexCall: connect_go.NewClient[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse](
			httpClient,
			baseURL+"/testing.v1.TestService/FullDuplexCall",
			opts...,
		),
	}
}

// testServiceClient implements TestServiceClient.
type testServiceClient struct {
	unaryHappy                   *connect_go.Client[v1.UnaryHappyRequest, v1.UnaryHappyResponse]
	unaryError                   *connect_go.Client[v1.UnaryErrorRequest, v1.UnaryErrorResponse]
	unaryHeaders                 *connect_go.Client[v1.UnaryHeadersRequest, v1.UnaryHeadersResponse]
	unaryTrailers                *connect_go.Client[v1.UnaryTrailersRequest, v1.UnaryTrailersResponse]
	unaryExpectHeaders           *connect_go.Client[v1.UnaryExpectHeadersRequest, v1.UnaryExpectHeadersResponse]
	unaryUnimplemented           *connect_go.Client[v1.UnaryUnimplementedRequest, v1.UnaryUnimplementedResponse]
	serverStreamingHappy         *connect_go.Client[v1.ServerStreamingHappyRequest, v1.ServerStreamingHappyResponse]
	serverStreamingError         *connect_go.Client[v1.ServerStreamingErrorRequest, v1.ServerStreamingErrorResponse]
	serverStreamingEmpty         *connect_go.Client[v1.ServerStreamingEmptyRequest, v1.ServerStreamingEmptyResponse]
	serverStreamingUnimplemented *connect_go.Client[v1.ServerStreamingUnimplementedRequest, v1.ServerStreamingUnimplementedResponse]
	fullDuplexCall               *connect_go.Client[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse]
}

// UnaryHappy calls testing.v1.TestService.UnaryHappy.
func (c *testServiceClient) UnaryHappy(ctx context.Context, req *connect_go.Request[v1.UnaryHappyRequest]) (*connect_go.Response[v1.UnaryHappyResponse], error) {
	return c.unaryHappy.CallUnary(ctx, req)
}

// UnaryError calls testing.v1.TestService.UnaryError.
func (c *testServiceClient) UnaryError(ctx context.Context, req *connect_go.Request[v1.UnaryErrorRequest]) (*connect_go.Response[v1.UnaryErrorResponse], error) {
	return c.unaryError.CallUnary(ctx, req)
}

// UnaryHeaders calls testing.v1.TestService.UnaryHeaders.
func (c *testServiceClient) UnaryHeaders(ctx context.Context, req *connect_go.Request[v1.UnaryHeadersRequest]) (*connect_go.Response[v1.UnaryHeadersResponse], error) {
	return c.unaryHeaders.CallUnary(ctx, req)
}

// UnaryTrailers calls testing.v1.TestService.UnaryTrailers.
func (c *testServiceClient) UnaryTrailers(ctx context.Context, req *connect_go.Request[v1.UnaryTrailersRequest]) (*connect_go.Response[v1.UnaryTrailersResponse], error) {
	return c.unaryTrailers.CallUnary(ctx, req)
}

// UnaryExpectHeaders calls testing.v1.TestService.UnaryExpectHeaders.
func (c *testServiceClient) UnaryExpectHeaders(ctx context.Context, req *connect_go.Request[v1.UnaryExpectHeadersRequest]) (*connect_go.Response[v1.UnaryExpectHeadersResponse], error) {
	return c.unaryExpectHeaders.CallUnary(ctx, req)
}

// UnaryUnimplemented calls testing.v1.TestService.UnaryUnimplemented.
func (c *testServiceClient) UnaryUnimplemented(ctx context.Context, req *connect_go.Request[v1.UnaryUnimplementedRequest]) (*connect_go.Response[v1.UnaryUnimplementedResponse], error) {
	return c.unaryUnimplemented.CallUnary(ctx, req)
}

// ServerStreamingHappy calls testing.v1.TestService.ServerStreamingHappy.
func (c *testServiceClient) ServerStreamingHappy(ctx context.Context, req *connect_go.Request[v1.ServerStreamingHappyRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingHappyResponse], error) {
	return c.serverStreamingHappy.CallServerStream(ctx, req)
}

// ServerStreamingError calls testing.v1.TestService.ServerStreamingError.
func (c *testServiceClient) ServerStreamingError(ctx context.Context, req *connect_go.Request[v1.ServerStreamingErrorRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingErrorResponse], error) {
	return c.serverStreamingError.CallServerStream(ctx, req)
}

// ServerStreamingEmpty calls testing.v1.TestService.ServerStreamingEmpty.
func (c *testServiceClient) ServerStreamingEmpty(ctx context.Context, req *connect_go.Request[v1.ServerStreamingEmptyRequest]) (*connect_go.ServerStreamForClient[v1.ServerStreamingEmptyResponse], error) {
	return c.serverStreamingEmpty.CallServerStream(ctx, req)
}

// ServerStreamingUnimplemented calls testing.v1.TestService.ServerStreamingUnimplemented.
func (c *testServiceClient) ServerStreamingUnimplemented(ctx context.Context, req *connect_go.Request[v1.ServerStreamingUnimplementedRequest]) (*connect_go.Response[v1.ServerStreamingUnimplementedResponse], error) {
	return c.serverStreamingUnimplemented.CallUnary(ctx, req)
}

// FullDuplexCall calls testing.v1.TestService.FullDuplexCall.
func (c *testServiceClient) FullDuplexCall(ctx context.Context) *connect_go.BidiStreamForClient[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse] {
	return c.fullDuplexCall.CallBidiStream(ctx)
}

// TestServiceHandler is an implementation of the testing.v1.TestService service.
type TestServiceHandler interface {
	// Returns the numeric value from the request as a string in the response
	UnaryHappy(context.Context, *connect_go.Request[v1.UnaryHappyRequest]) (*connect_go.Response[v1.UnaryHappyResponse], error)
	// Always raises an error "already_exists", and a message with whitespace
	// and unicode content
	UnaryError(context.Context, *connect_go.Request[v1.UnaryErrorRequest]) (*connect_go.Response[v1.UnaryErrorResponse], error)
	// Responds with headers:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar,baz
	UnaryHeaders(context.Context, *connect_go.Request[v1.UnaryHeadersRequest]) (*connect_go.Response[v1.UnaryHeadersResponse], error)
	// Responds with trailers:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar,baz
	UnaryTrailers(context.Context, *connect_go.Request[v1.UnaryTrailersRequest]) (*connect_go.Response[v1.UnaryTrailersResponse], error)
	// Expects a set of headers in the request:
	// single-value: foo
	// separate-values: bar
	// separate-values: baz
	// joined-values: bar, baz
	// Clients may join the two `separate-values` headers into one, with values
	// separated by `, `. Errors with invalid_argument if not met.
	UnaryExpectHeaders(context.Context, *connect_go.Request[v1.UnaryExpectHeadersRequest]) (*connect_go.Response[v1.UnaryExpectHeadersResponse], error)
	// Not implemented by the server
	UnaryUnimplemented(context.Context, *connect_go.Request[v1.UnaryUnimplementedRequest]) (*connect_go.Response[v1.UnaryUnimplementedResponse], error)
	// Returns exactly 5 responses. The value from the request is incremented
	// and given in each response.
	ServerStreamingHappy(context.Context, *connect_go.Request[v1.ServerStreamingHappyRequest], *connect_go.ServerStream[v1.ServerStreamingHappyResponse]) error
	// Always raises an error "already_exists", and a message with whitespace
	// and unicode content
	ServerStreamingError(context.Context, *connect_go.Request[v1.ServerStreamingErrorRequest], *connect_go.ServerStream[v1.ServerStreamingErrorResponse]) error
	ServerStreamingEmpty(context.Context, *connect_go.Request[v1.ServerStreamingEmptyRequest], *connect_go.ServerStream[v1.ServerStreamingEmptyResponse]) error
	ServerStreamingUnimplemented(context.Context, *connect_go.Request[v1.ServerStreamingUnimplementedRequest]) (*connect_go.Response[v1.ServerStreamingUnimplementedResponse], error)
	// A sequence of requests with each request served by the server immediately.
	// As one request could lead to multiple responses, this interface
	// demonstrates the idea of full duplexing.
	FullDuplexCall(context.Context, *connect_go.BidiStream[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse]) error
}

// NewTestServiceHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTestServiceHandler(svc TestServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/testing.v1.TestService/UnaryHappy", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryHappy",
		svc.UnaryHappy,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/UnaryError", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryError",
		svc.UnaryError,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/UnaryHeaders", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryHeaders",
		svc.UnaryHeaders,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/UnaryTrailers", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryTrailers",
		svc.UnaryTrailers,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/UnaryExpectHeaders", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryExpectHeaders",
		svc.UnaryExpectHeaders,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/UnaryUnimplemented", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/UnaryUnimplemented",
		svc.UnaryUnimplemented,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/ServerStreamingHappy", connect_go.NewServerStreamHandler(
		"/testing.v1.TestService/ServerStreamingHappy",
		svc.ServerStreamingHappy,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/ServerStreamingError", connect_go.NewServerStreamHandler(
		"/testing.v1.TestService/ServerStreamingError",
		svc.ServerStreamingError,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/ServerStreamingEmpty", connect_go.NewServerStreamHandler(
		"/testing.v1.TestService/ServerStreamingEmpty",
		svc.ServerStreamingEmpty,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/ServerStreamingUnimplemented", connect_go.NewUnaryHandler(
		"/testing.v1.TestService/ServerStreamingUnimplemented",
		svc.ServerStreamingUnimplemented,
		opts...,
	))
	mux.Handle("/testing.v1.TestService/FullDuplexCall", connect_go.NewBidiStreamHandler(
		"/testing.v1.TestService/FullDuplexCall",
		svc.FullDuplexCall,
		opts...,
	))
	return "/testing.v1.TestService/", mux
}

// UnimplementedTestServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTestServiceHandler struct{}

func (UnimplementedTestServiceHandler) UnaryHappy(context.Context, *connect_go.Request[v1.UnaryHappyRequest]) (*connect_go.Response[v1.UnaryHappyResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryHappy is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryError(context.Context, *connect_go.Request[v1.UnaryErrorRequest]) (*connect_go.Response[v1.UnaryErrorResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryError is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryHeaders(context.Context, *connect_go.Request[v1.UnaryHeadersRequest]) (*connect_go.Response[v1.UnaryHeadersResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryHeaders is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryTrailers(context.Context, *connect_go.Request[v1.UnaryTrailersRequest]) (*connect_go.Response[v1.UnaryTrailersResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryTrailers is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryExpectHeaders(context.Context, *connect_go.Request[v1.UnaryExpectHeadersRequest]) (*connect_go.Response[v1.UnaryExpectHeadersResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryExpectHeaders is not implemented"))
}

func (UnimplementedTestServiceHandler) UnaryUnimplemented(context.Context, *connect_go.Request[v1.UnaryUnimplementedRequest]) (*connect_go.Response[v1.UnaryUnimplementedResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.UnaryUnimplemented is not implemented"))
}

func (UnimplementedTestServiceHandler) ServerStreamingHappy(context.Context, *connect_go.Request[v1.ServerStreamingHappyRequest], *connect_go.ServerStream[v1.ServerStreamingHappyResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.ServerStreamingHappy is not implemented"))
}

func (UnimplementedTestServiceHandler) ServerStreamingError(context.Context, *connect_go.Request[v1.ServerStreamingErrorRequest], *connect_go.ServerStream[v1.ServerStreamingErrorResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.ServerStreamingError is not implemented"))
}

func (UnimplementedTestServiceHandler) ServerStreamingEmpty(context.Context, *connect_go.Request[v1.ServerStreamingEmptyRequest], *connect_go.ServerStream[v1.ServerStreamingEmptyResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.ServerStreamingEmpty is not implemented"))
}

func (UnimplementedTestServiceHandler) ServerStreamingUnimplemented(context.Context, *connect_go.Request[v1.ServerStreamingUnimplementedRequest]) (*connect_go.Response[v1.ServerStreamingUnimplementedResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.ServerStreamingUnimplemented is not implemented"))
}

func (UnimplementedTestServiceHandler) FullDuplexCall(context.Context, *connect_go.BidiStream[v1.FullDuplexCallRequest, v1.FullDuplexCallResponse]) error {
	return connect_go.NewError(connect_go.CodeUnimplemented, errors.New("testing.v1.TestService.FullDuplexCall is not implemented"))
}
