// Copyright 2021-2024 The Connect Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// @generated by protoc-gen-es v1.10.0 with parameter "ts_nocheck=false,target=ts"
// @generated from file buf/registry/module/v1beta1/download_service.proto (package buf.registry.module.v1beta1, syntax proto3)
/* eslint-disable */

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { DigestType } from "./digest_pb.js";
import { ResourceRef } from "./resource_pb.js";
import { File, FileType } from "./file_pb.js";
import { Commit } from "./commit_pb.js";

/**
 * @generated from message buf.registry.module.v1beta1.DownloadRequest
 */
export class DownloadRequest extends Message<DownloadRequest> {
  /**
   * The references to get contents for.
   *
   * @generated from field: repeated buf.registry.module.v1beta1.DownloadRequest.Value values = 1;
   */
  values: DownloadRequest_Value[] = [];

  /**
   * The DigestType to return for the Commits of the references.
   *
   * If this DigestType is not available, an error is returned.
   * Note that certain DigestTypes may be deprecated over time.
   *
   * If not set, the latest DigestType is used, currently B5.
   *
   * @generated from field: buf.registry.module.v1beta1.DigestType digest_type = 2;
   */
  digestType = DigestType.UNSPECIFIED;

  constructor(data?: PartialMessage<DownloadRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "buf.registry.module.v1beta1.DownloadRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: DownloadRequest_Value, repeated: true },
    { no: 2, name: "digest_type", kind: "enum", T: proto3.getEnumType(DigestType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadRequest {
    return new DownloadRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadRequest {
    return new DownloadRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadRequest {
    return new DownloadRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DownloadRequest | PlainMessage<DownloadRequest> | undefined, b: DownloadRequest | PlainMessage<DownloadRequest> | undefined): boolean {
    return proto3.util.equals(DownloadRequest, a, b);
  }
}

/**
 * A request for content for a single reference.
 *
 * @generated from message buf.registry.module.v1beta1.DownloadRequest.Value
 */
export class DownloadRequest_Value extends Message<DownloadRequest_Value> {
  /**
   * The reference to get content for.
   *
   * See the documentation on ResourceRef for resource resolution details.
   *
   * Once the resource is resolved, the following content is returned:
   *   - If a Module is referenced, the content of the Commit of the default Label is returned.
   *   - If a Label is referenced, the content of the Commit of this Label is returned.
   *   - If a Commit is referenced, the content for this Commit is returned.
   *
   * @generated from field: buf.registry.module.v1beta1.ResourceRef resource_ref = 1;
   */
  resourceRef?: ResourceRef;

  /**
   * Specific file types to request.
   *
   * If not set, all file types are returned.
   *
   * @generated from field: repeated buf.registry.module.v1beta1.FileType file_types = 2;
   */
  fileTypes: FileType[] = [];

  /**
   * Specific file paths to retrieve.
   *
   * May be directories. For example, path "foo/bar" will result in files "foo/bar/baz.proto",
   * "foo/bar/LICENSE" being downloaded.
   *
   * If empty, all file paths for the given reference are retrieved.
   *
   * If no paths match, an empty Files list will be returned, however the call may still
   * be successful if paths_allow_not_exist is set (the dependency list may still be on
   * the response). If a directory "foo/bar" is specified but this directory has no files,
   * this is considered to be a non-match.
   *
   * This field also interacts with file_types - if file_types is set, a path only matches
   * if it is also of the file type, and if there are no matching paths for the given FileTypes,
   * an error is returned unless paths_not_allow_exist is set.
   *
   * The path must be relative, and cannot contain any "." or ".." components
   * The separator "/" must be used.
   *
   * @generated from field: repeated string paths = 3;
   */
  paths: string[] = [];

  /**
   * Whether to allow file paths not to exist within the given module.
   *
   * For example, one may want to retrieve the file paths "buf.md" and "README.md",
   * but only expect one to actually exist.
   *
   * If false, it is an error to specify non-existent file paths.
   *
   * @generated from field: bool paths_allow_not_exist = 4;
   */
  pathsAllowNotExist = false;

  constructor(data?: PartialMessage<DownloadRequest_Value>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "buf.registry.module.v1beta1.DownloadRequest.Value";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "resource_ref", kind: "message", T: ResourceRef },
    { no: 2, name: "file_types", kind: "enum", T: proto3.getEnumType(FileType), repeated: true },
    { no: 3, name: "paths", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 4, name: "paths_allow_not_exist", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadRequest_Value {
    return new DownloadRequest_Value().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadRequest_Value {
    return new DownloadRequest_Value().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadRequest_Value {
    return new DownloadRequest_Value().fromJsonString(jsonString, options);
  }

  static equals(a: DownloadRequest_Value | PlainMessage<DownloadRequest_Value> | undefined, b: DownloadRequest_Value | PlainMessage<DownloadRequest_Value> | undefined): boolean {
    return proto3.util.equals(DownloadRequest_Value, a, b);
  }
}

/**
 * @generated from message buf.registry.module.v1beta1.DownloadResponse
 */
export class DownloadResponse extends Message<DownloadResponse> {
  /**
   * The Contents of the references in the same order as requested.
   *
   * @generated from field: repeated buf.registry.module.v1beta1.DownloadResponse.Content contents = 1;
   */
  contents: DownloadResponse_Content[] = [];

  constructor(data?: PartialMessage<DownloadResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "buf.registry.module.v1beta1.DownloadResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "contents", kind: "message", T: DownloadResponse_Content, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadResponse {
    return new DownloadResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadResponse {
    return new DownloadResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadResponse {
    return new DownloadResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DownloadResponse | PlainMessage<DownloadResponse> | undefined, b: DownloadResponse | PlainMessage<DownloadResponse> | undefined): boolean {
    return proto3.util.equals(DownloadResponse, a, b);
  }
}

/**
 * Content for a single Commit.
 *
 * @generated from message buf.registry.module.v1beta1.DownloadResponse.Content
 */
export class DownloadResponse_Content extends Message<DownloadResponse_Content> {
  /**
   * The Commit associated with the Content.
   *
   * The Commit associated with this ID will be present in the commits field.
   *
   * The Commit will use the DigestType specified in the request value.
   *
   * @generated from field: buf.registry.module.v1beta1.Commit commit = 1;
   */
  commit?: Commit;

  /**
   * The Files of the content.
   *
   * This will consist of the .proto files, license files, and documentation files.
   *
   * If no paths match and paths_allow_not_exist is set, this may be empty.
   *
   * @generated from field: repeated buf.registry.module.v1beta1.File files = 2;
   */
  files: File[] = [];

  /**
   * The original v1beta1 or v1 buf.yaml file that encapsulated this reference.
   *
   * If the reference was encapsulated by a v2 buf.yaml, this will be a synthesized v1 buf.yaml.
   *
   * This is used in deprecated digest calculations only. None of the structured
   * information within this File conveys further information about the reference.
   *
   * @generated from field: buf.registry.module.v1beta1.File v1_buf_yaml_file = 3;
   */
  v1BufYamlFile?: File;

  /**
   * The original buf.lock file that encapsulated this reference, if it existed.
   *
   * If the reference was encapsulated by a v2 buf.lock with dependencies, this will be a
   * synthesized v1 buf.lock.
   *
   * This is used in deprecated digest calculations only. None of the structured
   * information within this File conveys further information about the reference.
   *
   * Importantly, this file should *not* used to determine the dependencies of the
   * reference. To determine the dependencies, use the GraphService with the returned
   * Commit.
   *
   * @generated from field: buf.registry.module.v1beta1.File v1_buf_lock_file = 4;
   */
  v1BufLockFile?: File;

  constructor(data?: PartialMessage<DownloadResponse_Content>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "buf.registry.module.v1beta1.DownloadResponse.Content";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "commit", kind: "message", T: Commit },
    { no: 2, name: "files", kind: "message", T: File, repeated: true },
    { no: 3, name: "v1_buf_yaml_file", kind: "message", T: File },
    { no: 4, name: "v1_buf_lock_file", kind: "message", T: File },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DownloadResponse_Content {
    return new DownloadResponse_Content().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DownloadResponse_Content {
    return new DownloadResponse_Content().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DownloadResponse_Content {
    return new DownloadResponse_Content().fromJsonString(jsonString, options);
  }

  static equals(a: DownloadResponse_Content | PlainMessage<DownloadResponse_Content> | undefined, b: DownloadResponse_Content | PlainMessage<DownloadResponse_Content> | undefined): boolean {
    return proto3.util.equals(DownloadResponse_Content, a, b);
  }
}

